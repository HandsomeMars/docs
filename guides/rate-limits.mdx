---
title: "Rate Limits"
description: "Understanding and working with JoggAI API rate limits"
---

## Overview

JoggAI API implements rate limiting to ensure fair usage and maintain service quality for all users. Rate limits are applied per API key and vary based on your subscription plan.

<Info>
  Rate limits reset every 60 seconds. Plan your API calls accordingly to avoid interruptions.
</Info>

## Current Rate Limits

### Default Limits

| Limit Type | Free Plan | Pro Plan | Enterprise |
|------------|-----------|----------|------------|
| **Requests per minute** | 20 | 60 | 300 |
| **Burst requests** | 30 | 100 | 500 |
| **Concurrent video generation** | 2 | 10 | 50 |
| **Webhook calls per minute** | 10 | 30 | 100 |

<Note>
  Enterprise plans can request custom rate limits. Contact [sales@jogg.ai](mailto:sales@jogg.ai) for more information.
</Note>

## Rate Limit Headers

Every API response includes rate limit information in the headers:

```bash
curl -v -X GET 'https://api.jogg.ai/open/v2/user/whoami' \
  -H 'x-api-key: YOUR_API_KEY'
```

**Response Headers:**

```
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 59
X-RateLimit-Reset: 1640995200
X-RateLimit-Type: user
```

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests allowed per minute |
| `X-RateLimit-Remaining` | Number of requests remaining in current window |
| `X-RateLimit-Reset` | Unix timestamp when the rate limit resets |
| `X-RateLimit-Type` | Type of rate limit applied (user, endpoint, etc.) |

## Checking Rate Limits

Monitor your rate limit status by inspecting response headers:

```bash
response=$(curl -i -s -X GET 'https://api.jogg.ai/open/v2/user/whoami' \
  -H 'x-api-key: YOUR_API_KEY')

limit=$(echo "$response" | grep -i "X-RateLimit-Limit:" | cut -d' ' -f2)
remaining=$(echo "$response" | grep -i "X-RateLimit-Remaining:" | cut -d' ' -f2)
reset=$(echo "$response" | grep -i "X-RateLimit-Reset:" | cut -d' ' -f2)

echo "Rate Limit: $remaining/$limit remaining"
echo "Resets at: $(date -r $reset)"
```

## Rate Limit Exceeded

When you exceed the rate limit, you'll receive a `429` HTTP status code:

```json
{
  "code": 10401,
  "msg": "Rate limit exceeded. Please try again later.",
  "data": {
    "retryAfter": 30,
    "limit": 60,
    "current": 61
  }
}
```

The response includes:
- `retryAfter`: Seconds to wait before retrying
- `limit`: Your rate limit
- `current`: Number of requests in the current window

## Handling Rate Limits

### Strategy 1: Exponential Backoff

Implement exponential backoff when you hit rate limits:

```bash
make_api_request() {
  local max_retries=5
  local retry_count=0
  
  while [ $retry_count -lt $max_retries ]; do
    response=$(curl -s -w "\n%{http_code}" -X GET 'https://api.jogg.ai/open/v2/user/whoami' \
      -H 'x-api-key: YOUR_API_KEY')
    
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | head -n-1)
    
    if [ "$http_code" = "429" ]; then
      wait_time=$((2 ** retry_count))
      echo "Rate limited. Waiting ${wait_time} seconds..."
      sleep $wait_time
      retry_count=$((retry_count + 1))
    elif [ "$http_code" = "200" ]; then
      echo "$body"
      return 0
    else
      echo "Error: HTTP $http_code"
      return 1
    fi
  done
  
  echo "Max retries exceeded"
  return 1
}
```

### Strategy 2: Rate Limit Tracking

Track your rate limit usage proactively:

```bash
track_rate_limit() {
  response=$(curl -i -s -X GET 'https://api.jogg.ai/open/v2/user/whoami' \
    -H 'x-api-key: YOUR_API_KEY')
  
  remaining=$(echo "$response" | grep -i "X-RateLimit-Remaining:" | awk '{print $2}' | tr -d '\r')
  limit=$(echo "$response" | grep -i "X-RateLimit-Limit:" | awk '{print $2}' | tr -d '\r')
  
  if [ "$remaining" -lt 5 ]; then
    echo "Warning: Only $remaining requests remaining out of $limit"
    return 1
  fi
  
  return 0
}

# Use before making requests
if track_rate_limit; then
  # Safe to make request
  curl -X POST 'https://api.jogg.ai/open/v2/product' \
    -H 'x-api-key: YOUR_API_KEY' \
    -H 'Content-Type: application/json' \
    -d '{"name": "Product"}'
else
  echo "Approaching rate limit. Waiting..."
  sleep 10
fi
```

### Strategy 3: Request Queuing

Implement a queue to manage requests:

```bash
request_queue=()
max_concurrent=5
current_concurrent=0

add_to_queue() {
  request_queue+=("$1")
}

process_queue() {
  while [ ${#request_queue[@]} -gt 0 ]; do
    if [ $current_concurrent -lt $max_concurrent ]; then
      request="${request_queue[0]}"
      request_queue=("${request_queue[@]:1}")
      
      # Execute request in background
      execute_request "$request" &
      current_concurrent=$((current_concurrent + 1))
    else
      sleep 1
    fi
  done
}

execute_request() {
  curl -X GET "$1" -H 'x-api-key: YOUR_API_KEY'
  current_concurrent=$((current_concurrent - 1))
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="1. Cache Responses">
    Cache frequently accessed data to reduce API calls:
    
    ```bash
    cache_dir="/tmp/joggai_cache"
    cache_ttl=300  # 5 minutes
    
    cached_request() {
      local endpoint=$1
      local cache_key=$(echo "$endpoint" | md5sum | cut -d' ' -f1)
      local cache_file="$cache_dir/$cache_key"
      
      # Check if cache exists and is valid
      if [ -f "$cache_file" ]; then
        local age=$(($(date +%s) - $(stat -f%m "$cache_file")))
        if [ $age -lt $cache_ttl ]; then
          cat "$cache_file"
          return 0
        fi
      fi
      
      # Fetch and cache
      response=$(curl -s -X GET "$endpoint" -H 'x-api-key: YOUR_API_KEY')
      mkdir -p "$cache_dir"
      echo "$response" > "$cache_file"
      echo "$response"
    }
    ```
  </Accordion>
  
  <Accordion title="2. Use Webhooks Instead of Polling">
    Instead of polling for video status, use webhooks:
    
    **Bad: Polling every 10 seconds**
    ```bash
    while true; do
      status=$(curl -s -X GET "https://api.jogg.ai/open/v2/videos/$VIDEO_ID" \
        -H 'x-api-key: YOUR_API_KEY')
      # This uses 6 requests per minute!
      sleep 10
    done
    ```
    
    **Good: Use webhooks**
    ```bash
    # Set up webhook once
    curl -X POST 'https://api.jogg.ai/open/v2/webhooks' \
      -H 'x-api-key: YOUR_API_KEY' \
      -H 'Content-Type: application/json' \
      -d '{
        "url": "https://your-server.com/webhook",
        "events": ["video.completed"]
      }'
    ```
  </Accordion>
  
  <Accordion title="3. Batch Requests When Possible">
    Group multiple operations into batch requests where supported:
    
    ```bash
    # Instead of multiple individual requests
    # Make one batch request if the endpoint supports it
    curl -X POST 'https://api.jogg.ai/open/v2/batch' \
      -H 'x-api-key: YOUR_API_KEY' \
      -H 'Content-Type: application/json' \
      -d '{
        "requests": [
          {"method": "GET", "path": "/avatars"},
          {"method": "GET", "path": "/voices"}
        ]
      }'
    ```
  </Accordion>
  
  <Accordion title="4. Monitor Your Usage">
    Track your API usage to identify optimization opportunities:
    
    ```bash
    log_api_call() {
      local endpoint=$1
      local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      echo "[$timestamp] $endpoint" >> /var/log/joggai_usage.log
    }
    
    # Analyze usage patterns
    analyze_usage() {
      echo "API calls in the last minute:"
      tail -n 100 /var/log/joggai_usage.log | \
        grep "$(date -u +"%Y-%m-%dT%H:%M")" | \
        wc -l
    }
    ```
  </Accordion>
  
  <Accordion title="5. Implement Circuit Breaker">
    Prevent cascading failures with a circuit breaker pattern:
    
    ```bash
    circuit_state="closed"
    failure_count=0
    failure_threshold=5
    
    api_request_with_circuit_breaker() {
      if [ "$circuit_state" = "open" ]; then
        echo "Circuit breaker is open. Skipping request."
        return 1
      fi
      
      response=$(curl -s -w "\n%{http_code}" -X GET "$1" \
        -H 'x-api-key: YOUR_API_KEY')
      
      http_code=$(echo "$response" | tail -n1)
      
      if [ "$http_code" = "429" ]; then
        failure_count=$((failure_count + 1))
        if [ $failure_count -ge $failure_threshold ]; then
          circuit_state="open"
          echo "Circuit breaker opened after $failure_count failures"
          # Auto-reset after 60 seconds
          (sleep 60 && circuit_state="closed" && failure_count=0) &
        fi
        return 1
      else
        failure_count=0
        echo "$response" | head -n-1
        return 0
      fi
    }
    ```
  </Accordion>
</AccordionGroup>

## Endpoint-Specific Limits

Some endpoints have additional limits:

| Endpoint | Limit | Window |
|----------|-------|--------|
| `/product` | 30 requests | Per minute |
| `/videos` | 10 concurrent | At any time |
| `/ai-scripts` | 20 requests | Per minute |
| `/upload` | 5 GB | Per day |

## Upgrading Your Limits

Need higher rate limits?

<CardGroup cols={2}>
  <Card title="Upgrade Plan" icon="arrow-up">
    Upgrade to Pro or Enterprise for higher limits
    
    [View Plans](https://jogg.ai/pricing)
  </Card>
  
  <Card title="Contact Sales" icon="phone">
    Need custom limits? Contact our sales team
    
    [sales@jogg.ai](mailto:sales@jogg.ai)
  </Card>
</CardGroup>

## Monitoring Tools

### Check Current Usage

```bash
curl -X GET 'https://api.jogg.ai/open/v2/usage/stats' \
  -H 'x-api-key: YOUR_API_KEY'
```

**Response:**

```json
{
  "code": 0,
  "msg": "Success",
  "data": {
    "requestsToday": 150,
    "requestsThisMonth": 4500,
    "rateLimit": {
      "limit": 60,
      "remaining": 58,
      "resetAt": "2024-01-01T12:01:00Z"
    }
  }
}
```

## Common Issues

<AccordionGroup>
  <Accordion title="Hitting Limits Unexpectedly">
    **Possible Causes:**
    - Multiple systems using the same API key
    - Polling instead of using webhooks
    - No caching implemented
    
    **Solutions:**
    - Use separate API keys for different systems
    - Implement webhooks for async operations
    - Cache frequently accessed data
  </Accordion>
  
  <Accordion title="Rate Limits Not Resetting">
    **Possible Causes:**
    - Misunderstanding the reset window
    - Time zone confusion
    
    **Solutions:**
    - Check the `X-RateLimit-Reset` header (Unix timestamp in UTC)
    - Implement proper time handling in your code
  </Accordion>
  
  <Accordion title="Inconsistent Rate Limit Responses">
    **Possible Causes:**
    - Multiple API keys in use
    - Requests hitting different servers
    
    **Solutions:**
    - Consolidate to fewer API keys
    - Track limits per API key separately
  </Accordion>
</AccordionGroup>

## Need Help?

If you're experiencing rate limit issues:

1. Check your current usage in the [Dashboard](https://dashboard.jogg.ai)
2. Review the rate limit headers in your responses
3. Implement one of the handling strategies above
4. Contact support at [support@jogg.ai](mailto:support@jogg.ai) for assistance

<Tip>
  Pro tip: Set up monitoring alerts when you reach 80% of your rate limit to prevent unexpected service interruptions.
</Tip>
